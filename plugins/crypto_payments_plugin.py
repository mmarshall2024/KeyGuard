from plugins.base_plugin import BasePlugin
import requests
import json
import hashlib
import hmac
import time
from datetime import datetime, timedelta

class CryptoPaymentsPlugin(BasePlugin):
    """Cryptocurrency payment processing plugin"""
    
    def __init__(self):
        super().__init__()
        self.version = "1.0.0"
        self.description = "Process cryptocurrency payments with multiple providers"
        
        # Supported cryptocurrencies
        self.supported_cryptos = {
            'BTC': {'name': 'Bitcoin', 'decimals': 8},
            'ETH': {'name': 'Ethereum', 'decimals': 18},
            'USDT': {'name': 'Tether USD', 'decimals': 6},
            'USDC': {'name': 'USD Coin', 'decimals': 6},
            'LTC': {'name': 'Litecoin', 'decimals': 8},
            'ADA': {'name': 'Cardano', 'decimals': 6},
            'DOT': {'name': 'Polkadot', 'decimals': 10}
        }
        
        # Payment providers configuration
        self.coinbase_api_key = self.get_config("COINBASE_API_KEY")
        self.coinbase_webhook_secret = self.get_config("COINBASE_WEBHOOK_SECRET")
        self.nowpayments_api_key = self.get_config("NOWPAYMENTS_API_KEY")
        
    def register_commands(self, application=None):
        """Register crypto payment commands"""
        self.add_command("crypto_pay", self.create_payment, "Create cryptocurrency payment")
        self.add_command("crypto_status", self.check_payment_status, "Check payment status")
        self.add_command("crypto_rates", self.get_crypto_rates, "Get current cryptocurrency rates")
        self.add_command("crypto_wallets", self.show_supported_cryptos, "Show supported cryptocurrencies")
        
        self.log(f"{self.name} commands registered successfully")
    
    def create_payment(self, chat_id=None, args=None):
        """Create a new cryptocurrency payment request"""
        if not args or len(args) < 2:
            return """ğŸ’° **Crypto Payment Creation**

Usage: crypto_pay [amount] [currency] [crypto_type]

Examples:
â€¢ crypto_pay 10 USD BTC (Pay $10 in Bitcoin)
â€¢ crypto_pay 25 EUR ETH (Pay â‚¬25 in Ethereum)
â€¢ crypto_pay 50 USD USDT (Pay $50 in USDT)

Supported cryptos: BTC, ETH, USDT, USDC, LTC, ADA, DOT
Supported currencies: USD, EUR, GBP"""
        
        try:
            amount = float(args[0])
            currency = args[1].upper() if len(args) > 1 else "USD"
            crypto_type = args[2].upper() if len(args) > 2 else "BTC"
            
            if crypto_type not in self.supported_cryptos:
                return f"âŒ Unsupported cryptocurrency: {crypto_type}\nSupported: {', '.join(self.supported_cryptos.keys())}"
            
            # Create payment using available provider
            if self.coinbase_api_key:
                return self._create_coinbase_payment(amount, currency, crypto_type, chat_id)
            elif self.nowpayments_api_key:
                return self._create_nowpayments_payment(amount, currency, crypto_type, chat_id)
            else:
                return self._create_manual_payment(amount, currency, crypto_type, chat_id)
                
        except ValueError:
            return "âŒ Invalid amount. Please enter a valid number."
        except Exception as e:
            self.log(f"Error creating crypto payment: {e}", "error")
            return "âŒ Error creating payment. Please try again."
    
    def _create_coinbase_payment(self, amount, currency, crypto_type, chat_id):
        """Create payment using Coinbase Commerce"""
        try:
            # Get current crypto rate
            crypto_amount = self._convert_to_crypto(amount, currency, crypto_type)
            
            payment_data = {
                "payment_id": f"omni_{int(time.time())}_{chat_id}",
                "amount": amount,
                "currency": currency,
                "crypto_type": crypto_type,
                "crypto_amount": crypto_amount,
                "status": "pending",
                "created_at": datetime.now().isoformat(),
                "expires_at": (datetime.now() + timedelta(hours=1)).isoformat()
            }
            
            # In a real implementation, you would call Coinbase Commerce API
            # For now, we'll simulate the response
            
            return f"""âœ… **Crypto Payment Created**

ğŸ’° Amount: {amount} {currency} (â‰ˆ {crypto_amount:.8f} {crypto_type})
ğŸª™ Cryptocurrency: {self.supported_cryptos[crypto_type]['name']}
ğŸ†” Payment ID: {payment_data['payment_id']}
â° Expires: 1 hour

ğŸ“ **Instructions:**
1. Send exactly {crypto_amount:.8f} {crypto_type} to the address below
2. Payment will be confirmed automatically
3. Do not send any other amount or cryptocurrency

ğŸ”— **Payment Address:** [Would be generated by provider]

âš ï¸ **Important:** 
â€¢ Send only {crypto_type} to this address
â€¢ Network fees are your responsibility
â€¢ Payment expires in 1 hour"""
            
        except Exception as e:
            self.log(f"Coinbase payment error: {e}", "error")
            return "âŒ Error with Coinbase payment provider."
    
    def _create_nowpayments_payment(self, amount, currency, crypto_type, chat_id):
        """Create payment using NOWPayments"""
        try:
            if not self.nowpayments_api_key:
                return "âŒ NOWPayments not configured."
            
            # NOWPayments API call
            url = "https://api.nowpayments.io/v1/payment"
            headers = {
                "x-api-key": self.nowpayments_api_key,
                "Content-Type": "application/json"
            }
            
            data = {
                "price_amount": amount,
                "price_currency": currency.lower(),
                "pay_currency": crypto_type.lower(),
                "order_id": f"omni_{int(time.time())}_{chat_id}",
                "order_description": "OMNICore Bot Service Payment"
            }
            
            response = requests.post(url, headers=headers, json=data, timeout=15)
            
            if response.status_code == 201:
                payment = response.json()
                
                return f"""âœ… **Crypto Payment Created (NOWPayments)**

ğŸ’° Amount: {amount} {currency} (â‰ˆ {payment.get('pay_amount', 0)} {crypto_type})
ğŸª™ Cryptocurrency: {self.supported_cryptos[crypto_type]['name']}
ğŸ†” Payment ID: {payment.get('payment_id', 'Unknown')}

ğŸ“ **Send to Address:**
`{payment.get('pay_address', 'Address not available')}`

ğŸ’¸ **Exact Amount:**
`{payment.get('pay_amount', 0)} {crypto_type}`

ğŸ” **Track Payment:**
Payment Status: {payment.get('payment_status', 'pending')}

âš ï¸ Send exactly the amount shown above!"""
            else:
                return f"âŒ NOWPayments API error: {response.status_code}"
                
        except Exception as e:
            self.log(f"NOWPayments error: {e}", "error")
            return "âŒ Error with NOWPayments provider."
    
    def _create_manual_payment(self, amount, currency, crypto_type, chat_id):
        """Create manual payment instructions when no provider is configured"""
        try:
            crypto_amount = self._convert_to_crypto(amount, currency, crypto_type)
            
            # Generate static wallet addresses (in production, use proper wallet generation)
            wallet_addresses = {
                'BTC': '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa',
                'ETH': '0x0000000000000000000000000000000000000000',
                'USDT': '0x0000000000000000000000000000000000000000',
                'USDC': '0x0000000000000000000000000000000000000000',
                'LTC': 'LTC1234567890abcdef',
                'ADA': 'addr1234567890abcdef',
                'DOT': 'DOT1234567890abcdef'
            }
            
            address = wallet_addresses.get(crypto_type, "Address not available")
            
            return f"""ğŸ’³ **Manual Crypto Payment**

ğŸ’° Amount: {amount} {currency} (â‰ˆ {crypto_amount:.8f} {crypto_type})
ğŸª™ Cryptocurrency: {self.supported_cryptos[crypto_type]['name']}
ğŸ†” Reference: OMNI_{int(time.time())}

ğŸ“ **Payment Address:**
`{address}`

ğŸ’¸ **Send Exactly:**
`{crypto_amount:.8f} {crypto_type}`

ğŸ“ **Instructions:**
1. Copy the address above
2. Send the exact amount from your wallet
3. Include transaction hash for verification
4. Confirmation may take 10-60 minutes

âš ï¸ **Warning:** 
â€¢ Wrong amount = Payment rejected
â€¢ Wrong cryptocurrency = Funds lost
â€¢ Network fees are additional

ğŸ”„ Use crypto_status [payment_id] to check status"""
            
        except Exception as e:
            self.log(f"Manual payment error: {e}", "error")
            return "âŒ Error generating payment instructions."
    
    def check_payment_status(self, chat_id=None, args=None):
        """Check the status of a cryptocurrency payment"""
        if not args:
            return """ğŸ” **Payment Status Check**

Usage: crypto_status [payment_id]

Example: crypto_status omni_1673123456_789

This will show:
â€¢ Payment confirmation status
â€¢ Transaction hash (if confirmed)
â€¢ Remaining confirmation time
â€¢ Any issues or errors"""
        
        payment_id = args[0]
        
        try:
            # In a real implementation, you would query the payment provider
            # For now, we'll simulate different payment statuses
            
            statuses = [
                {
                    "status": "pending",
                    "message": "â³ Payment pending - waiting for blockchain confirmation",
                    "confirmations": "1/3"
                },
                {
                    "status": "confirmed", 
                    "message": "âœ… Payment confirmed successfully!",
                    "tx_hash": "0x1234567890abcdef..."
                },
                {
                    "status": "expired",
                    "message": "â° Payment expired - please create a new payment"
                }
            ]
            
            # Simulate status based on payment_id
            import hashlib
            status_index = int(hashlib.md5(payment_id.encode()).hexdigest(), 16) % len(statuses)
            status = statuses[status_index]
            
            response = f"""ğŸ” **Payment Status**

ğŸ†” Payment ID: {payment_id}
ğŸ“Š Status: {status['message']}
"""
            
            if status.get("confirmations"):
                response += f"ğŸ”— Confirmations: {status['confirmations']}\n"
            
            if status.get("tx_hash"):
                response += f"ğŸ“ Transaction: {status['tx_hash']}\n"
            
            if status["status"] == "pending":
                response += "\nâ±ï¸ Typical confirmation time: 10-60 minutes"
            elif status["status"] == "expired":
                response += "\nğŸ”„ Create new payment with crypto_pay command"
            
            return response
            
        except Exception as e:
            self.log(f"Payment status error: {e}", "error")
            return "âŒ Error checking payment status."
    
    def get_crypto_rates(self, chat_id=None, args=None):
        """Get current cryptocurrency exchange rates"""
        try:
            # Use CoinGecko API for rates (free tier)
            crypto_list = ",".join([crypto.lower() for crypto in self.supported_cryptos.keys()])
            url = f"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,tether,usd-coin,litecoin,cardano,polkadot&vs_currencies=usd,eur"
            
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Map CoinGecko IDs to our crypto symbols
                crypto_mapping = {
                    'bitcoin': 'BTC',
                    'ethereum': 'ETH', 
                    'tether': 'USDT',
                    'usd-coin': 'USDC',
                    'litecoin': 'LTC',
                    'cardano': 'ADA',
                    'polkadot': 'DOT'
                }
                
                response_text = "ğŸ’± **Current Crypto Rates**\n\n"
                
                for coin_id, symbol in crypto_mapping.items():
                    if coin_id in data:
                        usd_price = data[coin_id].get('usd', 0)
                        eur_price = data[coin_id].get('eur', 0)
                        
                        response_text += f"**{symbol} ({self.supported_cryptos[symbol]['name']})**\n"
                        response_text += f"ğŸ’µ ${usd_price:,.4f} USD\n"
                        response_text += f"ğŸ’¶ â‚¬{eur_price:,.4f} EUR\n\n"
                
                response_text += "ğŸ“Š Rates updated in real-time from CoinGecko\n"
                response_text += "ğŸ’¡ Use crypto_pay to create payments at current rates"
                
                return response_text
            else:
                return "âŒ Unable to fetch current rates. Please try again."
                
        except Exception as e:
            self.log(f"Crypto rates error: {e}", "error")
            return "âŒ Error fetching cryptocurrency rates."
    
    def show_supported_cryptos(self, chat_id=None, args=None):
        """Show all supported cryptocurrencies"""
        response = "ğŸª™ **Supported Cryptocurrencies**\n\n"
        
        for symbol, info in self.supported_cryptos.items():
            response += f"**{symbol}** - {info['name']}\n"
            response += f"ğŸ“Š Decimals: {info['decimals']}\n"
            response += f"ğŸ’³ Payment: Supported\n\n"
        
        response += "ğŸ’¡ **How to pay:**\n"
        response += "â€¢ crypto_pay [amount] [currency] [crypto]\n"
        response += "â€¢ Example: crypto_pay 25 USD BTC\n\n"
        
        response += "ğŸ”— **Providers:**\n"
        if self.coinbase_api_key:
            response += "âœ… Coinbase Commerce\n"
        if self.nowpayments_api_key:
            response += "âœ… NOWPayments\n"
        if not self.coinbase_api_key and not self.nowpayments_api_key:
            response += "ğŸ“ Manual payments (configure API keys for automation)\n"
        
        return response
    
    def _convert_to_crypto(self, amount, currency, crypto_type):
        """Convert fiat amount to cryptocurrency amount"""
        try:
            # In a real implementation, you would call an exchange rate API
            # For now, we'll use approximate values
            
            crypto_rates_usd = {
                'BTC': 45000,
                'ETH': 2500, 
                'USDT': 1.0,
                'USDC': 1.0,
                'LTC': 90,
                'ADA': 0.45,
                'DOT': 7.5
            }
            
            # Convert to USD first if needed
            if currency == "EUR":
                amount = amount * 1.1  # Rough EUR to USD conversion
            elif currency == "GBP":
                amount = amount * 1.25  # Rough GBP to USD conversion
            
            # Convert USD to crypto
            crypto_rate = crypto_rates_usd.get(crypto_type, 1)
            crypto_amount = amount / crypto_rate
            
            return crypto_amount
            
        except Exception as e:
            self.log(f"Conversion error: {e}", "error")
            return 0.0
    
    def process_webhook(self, webhook_data, provider):
        """Process webhook notifications from payment providers"""
        try:
            if provider == "coinbase":
                return self._process_coinbase_webhook(webhook_data)
            elif provider == "nowpayments":
                return self._process_nowpayments_webhook(webhook_data)
            
        except Exception as e:
            self.log(f"Webhook processing error: {e}", "error")
            return False
    
    def _process_coinbase_webhook(self, webhook_data):
        """Process Coinbase Commerce webhook"""
        # Verify webhook signature and process payment confirmation
        # Implementation would depend on Coinbase Commerce webhook format
        self.log("Coinbase webhook received")
        return True
    
    def _process_nowpayments_webhook(self, webhook_data):
        """Process NOWPayments webhook"""
        # Verify webhook signature and process payment confirmation
        # Implementation would depend on NOWPayments webhook format
        self.log("NOWPayments webhook received")
        return True